= TDD-Plan für `get_content_details`
:toc: left
:toclevels: 3
:sectnums:

== Übersicht

=== Ziele

1. **Flexibilität**: Unterstützung von Programme Item IDs UND Content Document IDs
2. **Vollständige Metadaten**: Liefert alle verfügbaren Details für tiefere Analysen
3. **Erweiterung der bestehenden Tools**: Ergänzt `search_content` und `get_broadcast_schedule`
4. **Best Practices**: TDD, Spring Boot, Kotlin Idiome, hohe Testabdeckung
5. **Keine Video-URLs**: Nur `webCanonical` Links zur Mediathek liefern (wie bei `search_content`)

=== Motivation

Die bestehenden MCP-Tools (`search_content`, `get_broadcast_schedule`, `get_current_broadcast`) liefern Basis-Informationen über Content und Broadcasts. Sie geben IDs zurück, aber keine vollständigen Details.

`get_content_details` ermöglicht es einem LLM:

- Vollständige Metadaten abzufragen (lange Beschreibungen, Cast, Crew)
- Direkten Link zur ZDF Mediathek zu bekommen (`webCanonical`)
- Bilder in verschiedenen Auflösungen zu bekommen
- Related Content zu entdecken
- Verfügbarkeitszeiträume zu prüfen

=== Unterstützte ID-Typen

Das Tool soll zwei Arten von IDs verarbeiten:

1. **Programme Item IDs** (aus EPG/Broadcasts)
   - Format: `epg-{sender}-{datum}-{nr}` (z.B. `epg-3sat-180415_1513-100`)
   - API-Endpoint: `/cmdm/epg/programme-items/{id}`
   - Quelle: `get_broadcast_schedule`, `get_current_broadcast`

2. **Content Document IDs** (aus Search)
   - Format: Verschiedene Sophora-IDs (z.B. `collection-index-page-ard-collection-...`)
   - API-Endpoint: `/content/documents/{id}.json`
   - Quelle: `search_content`

Das Tool erkennt automatisch den ID-Typ und ruft den entsprechenden Endpoint auf.

== Phase 1: Test Setup & Mock-Daten

=== Aufgaben

==== 1.1 Test-JSON-Dateien erstellen

**Datei: `src/test/resources/__files/programme_item_details.json`**

Mock-Response für `/cmdm/epg/programme-items/{id}`:

[source,json]
----
{
  "id": "epg-zdf-250101_2015-100",
  "title": "Tatort: Der letzte Zeuge",
  "subtitle": "Kriminalfilm Deutschland 2024",
  "text": "Kommissarin Lena Odenthal ermittelt in einem mysteriösen Mordfall...",
  "leadParagraph": "Ein packender Krimi aus Ludwigshafen mit spannenden Wendungen.",
  "duration": 5400,
  "editorialDate": "2025-01-01T20:15:00+01:00",
  "tvService": "ZDF",
  "contentType": "episode",
  "hasVideo": true,
  "broadcasts": [
    {
      "airtimeBegin": "2025-01-01T20:15:00+01:00",
      "airtimeEnd": "2025-01-01T21:45:00+01:00",
      "tvService": "ZDF"
    }
  ],
  "brand": {
    "id": "tatort-brand-100",
    "title": "Tatort"
  },
  "teaserImageRef": {
    "title": "Tatort",
    "altText": "Kommissarin Lena Odenthal",
    "layouts": {
      "1280x720": "https://www.zdf.de/assets/tatort-100~1280x720.jpg",
      "768x432": "https://www.zdf.de/assets/tatort-100~768x432.jpg"
    }
  },
  "categories": ["Krimi", "Spielfilm"],
  "http://zdf.de/rels/target": {
    "http://zdf.de/rels/sharing-url": "https://www.zdf.de/filme/tatort/der-letzte-zeuge-100.html"
  },
  "relatedContent": [
    {
      "title": "Tatort: Die Episoden im Überblick",
      "target": "https://www.zdf.de/filme/tatort"
    }
  ]
}
----

**Datei: `src/test/resources/__files/content_document_details.json`**

Mock-Response für `/content/documents/{id}.json`:

[source,json]
----
{
  "id": "terra-x-faszination-erde-102",
  "externalId": "SCMS_terra-x-102",
  "title": "Terra X: Faszination Erde - Antarktis",
  "teasertext": "Dirk Steffens reist in die unwirtlichste Region der Erde.",
  "leadParagraph": "Eine spektakuläre Reise in die eisige Welt der Antarktis mit atemberaubenden Aufnahmen der einzigartigen Tierwelt.",
  "text": "Die Antarktis ist der kälteste, trockenste und windigste Kontinent der Erde. Trotzdem gibt es hier Leben...",
  "editorialDate": "2024-12-15T19:30:00+01:00",
  "contentType": "episode",
  "hasVideo": true,
  "webCanonical": "https://www.zdf.de/dokumentation/terra-x/faszination-erde-antarktis-102.html",
  "tvService": "ZDF",
  "endDate": "2026-01-01T00:00:00+01:00",
  "teaserImageRef": {
    "title": "Antarktis Pinguin",
    "altText": "Kaiserpinguine in der Antarktis",
    "copyrightNotice": "ZDF/BBC",
    "layouts": {
      "1920x1080": "https://www.zdf.de/assets/antarktis-102~1920x1080.jpg",
      "1280x720": "https://www.zdf.de/assets/antarktis-102~1280x720.jpg",
      "768x432": "https://www.zdf.de/assets/antarktis-102~768x432.jpg"
    }
  },
  "relatedContent": [
    {
      "title": "Alle Terra X Folgen",
      "target": "https://www.zdf.de/dokumentation/terra-x"
    }
  ]
}
----

==== 1.2 Model-Klassen definieren (Struktur für Kompilierung)

**Datei: `src/main/kotlin/eu/wiegandt/zdfmediathekmcp/model/ProgrammeItemDetails.kt`**

[source,kotlin]
----
package eu.wiegandt.zdfmediathekmcp.model

import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.fasterxml.jackson.annotation.JsonProperty
import java.time.OffsetDateTime

@JsonIgnoreProperties(ignoreUnknown = true)
data class ProgrammeItemDetails(
    val id: String,
    val title: String,
    val subtitle: String? = null,
    val text: String? = null,
    val leadParagraph: String? = null,
    val duration: Int? = null,
    val editorialDate: OffsetDateTime? = null,
    val tvService: String? = null,
    val contentType: String? = null,
    val hasVideo: Boolean = false,
    val broadcasts: List<BroadcastInfo>? = null,
    val brand: BrandInfo? = null,
    val teaserImageRef: ImageReference? = null,
    val categories: List<String>? = null,
    @field:JsonProperty("http://zdf.de/rels/target")
    val target: TargetContent? = null,
    val relatedContent: List<RelatedContentLink>? = null
)

@JsonIgnoreProperties(ignoreUnknown = true)
data class BroadcastInfo(
    val airtimeBegin: OffsetDateTime,
    val airtimeEnd: OffsetDateTime,
    val tvService: String
)

@JsonIgnoreProperties(ignoreUnknown = true)
data class BrandInfo(
    val id: String? = null,
    val title: String? = null
)

@JsonIgnoreProperties(ignoreUnknown = true)
data class ImageReference(
    val title: String? = null,
    val altText: String? = null,
    val copyrightNotice: String? = null,
    val layouts: Map<String, String>? = null
)

@JsonIgnoreProperties(ignoreUnknown = true)
data class TargetContent(
    @field:JsonProperty("http://zdf.de/rels/sharing-url")
    val sharingUrl: String? = null
)

@JsonIgnoreProperties(ignoreUnknown = true)
data class RelatedContentLink(
    val title: String? = null,
    val target: String? = null
)
----

**Datei: `src/main/kotlin/eu/wiegandt/zdfmediathekmcp/model/ContentDocumentDetails.kt`**

[source,kotlin]
----
package eu.wiegandt.zdfmediathekmcp.model

import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import java.time.OffsetDateTime

@JsonIgnoreProperties(ignoreUnknown = true)
data class ContentDocumentDetails(
    val id: String,
    val externalId: String? = null,
    val title: String,
    val teasertext: String? = null,
    val leadParagraph: String? = null,
    val text: String? = null,
    val editorialDate: OffsetDateTime? = null,
    val contentType: String? = null,
    val hasVideo: Boolean = false,
    val webCanonical: String? = null,
    val tvService: String? = null,
    val endDate: OffsetDateTime? = null,
    val teaserImageRef: ImageReference? = null,
    val relatedContent: List<RelatedContentLink>? = null
)
----

**Datei: `src/main/kotlin/eu/wiegandt/zdfmediathekmcp/model/ContentDetailsResponse.kt`**

[source,kotlin]
----
package eu.wiegandt.zdfmediathekmcp.model

import java.time.OffsetDateTime

/**
 * Response for the get_content_details MCP tool.
 *
 * Unified response structure for both programme items and content documents.
 * Only provides webCanonical links to ZDF Mediathek - no direct video URLs.
 */
data class ContentDetailsResponse(
    val id: String,
    val type: String, // "programme-item" or "content-document"
    val title: String,
    val subtitle: String? = null,
    val description: String? = null,
    val tvService: String? = null,
    val editorialDate: OffsetDateTime? = null,
    val duration: Int? = null,
    val hasVideo: Boolean,
    val webCanonical: String? = null,
    val availableUntil: OffsetDateTime? = null,
    val imageUrl: String? = null,
    val brand: String? = null,
    val categories: List<String>? = null,
    val relatedContent: List<RelatedContentInfo>? = null
)

data class RelatedContentInfo(
    val title: String,
    val url: String
)
----

==== 1.3 Service-Interface erweitern

**Datei: `src/main/kotlin/eu/wiegandt/zdfmediathekmcp/ZdfMediathekService.kt`**

Neue Methoden hinzufügen:

[source,kotlin]
----
@GetExchange("/cmdm/epg/programme-items/{id}")
fun getProgrammeItemDetails(
    @PathVariable id: String,
    @RequestParam(required = false) profile: String? = null
): ProgrammeItemDetails

@GetExchange("/content/documents/{id}.json")
fun getContentDocumentDetails(
    @PathVariable id: String,
    @RequestParam(required = false) profile: String? = null
): ContentDocumentDetails
----

==== 1.4 Service-Klasse erstellen (nur Struktur)

**Datei: `src/main/kotlin/eu/wiegandt/zdfmediathekmcp/ContentDetailsService.kt`**

[source,kotlin]
----
package eu.wiegandt.zdfmediathekmcp

import eu.wiegandt.zdfmediathekmcp.model.ContentDetailsResponse
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.ai.tool.annotation.Tool
import org.springframework.ai.tool.annotation.ToolParam
import org.springframework.stereotype.Component

@Component
class ContentDetailsService(
    private val zdfMediathekService: ZdfMediathekService
) {
    private val logger: Logger = LoggerFactory.getLogger(ContentDetailsService::class.java)

    @Tool(
        name = "get_content_details",
        description = "Get detailed information about specific ZDF Mediathek content. " +
                     "Supports programme item IDs (from broadcasts) and content document IDs (from search). " +
                     "Returns metadata and a direct link to watch the content in ZDF Mediathek."
    )
    fun getContentDetails(
        @ToolParam(description = "Content ID (programme item or document ID)", required = true)
        contentId: String,
        @ToolParam(description = "Output profile (optional, default: 'default')")
        profile: String? = null
    ): ContentDetailsResponse {
        TODO("Not yet implemented")
    }
}
----

==== 1.5 Test-Klassen anlegen

**Datei: `src/test/kotlin/eu/wiegandt/zdfmediathekmcp/ContentDetailsServiceTest.kt`**

[source,kotlin]
----
package eu.wiegandt.zdfmediathekmcp

import org.junit.jupiter.api.Test
import org.junit.jupiter.api.extension.ExtendWith
import org.mockito.InjectMocks
import org.mockito.Mock
import org.mockito.junit.jupiter.MockitoExtension

@ExtendWith(MockitoExtension::class)
class ContentDetailsServiceTest {

    @Mock
    private lateinit var zdfMediathekService: ZdfMediathekService

    @InjectMocks
    private lateinit var contentDetailsService: ContentDetailsService

    // Tests will be added in Phase 2
}
----

**Datei: `src/test/kotlin/eu/wiegandt/zdfmediathekmcp/ContentDetailsServiceIT.kt`**

[source,kotlin]
----
package eu.wiegandt.zdfmediathekmcp

import com.github.tomakehurst.wiremock.client.WireMock.*
import com.github.tomakehurst.wiremock.junit5.WireMockTest
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.TestPropertySource

@SpringBootTest
@WireMockTest(httpPort = 8089)
@TestPropertySource(
    properties = [
        "zdf.api.base-url=http://localhost:8089",
        "zdf.api.oauth2.token-uri=http://localhost:8089/oauth/token",
        "zdf.api.oauth2.client-id=test-client",
        "zdf.api.oauth2.client-secret=test-secret"
    ]
)
class ContentDetailsServiceIT {

    @Autowired
    private lateinit var contentDetailsService: ContentDetailsService

    // Tests will be added in Phase 3
}
----

== Phase 2: Unit Tests (ContentDetailsServiceTest)

=== Test-Szenarien

==== 2.1 Erfolgreiche Abfragen

[source,kotlin]
----
@Test
fun `getContentDetails with programme item ID returns details with webCanonical`() {
    // Given
    val programmeItemId = "epg-zdf-250101_2015-100"
    val mockDetails = ProgrammeItemDetails(
        id = programmeItemId,
        title = "Tatort",
        subtitle = "Kriminalfilm",
        duration = 5400,
        hasVideo = true,
        target = TargetContent(sharingUrl = "https://www.zdf.de/filme/tatort/der-letzte-zeuge-100.html")
    )

    given(zdfMediathekService.getProgrammeItemDetails(programmeItemId, null))
        .willReturn(mockDetails)

    // When
    val result = contentDetailsService.getContentDetails(programmeItemId)

    // Then
    assertThat(result.type).isEqualTo("programme-item")
    assertThat(result.webCanonical).isEqualTo("https://www.zdf.de/filme/tatort/der-letzte-zeuge-100.html")
}

@Test
fun `getContentDetails with content document ID returns details with webCanonical`() {
    // Given
    val documentId = "terra-x-faszination-erde-102"
    val mockDetails = ContentDocumentDetails(
        id = documentId,
        title = "Terra X",
        teasertext = "Faszination Erde",
        hasVideo = true,
        webCanonical = "https://www.zdf.de/dokumentation/terra-x/faszination-erde-antarktis-102.html"
    )

    given(zdfMediathekService.getContentDocumentDetails(documentId, null))
        .willReturn(mockDetails)

    // When
    val result = contentDetailsService.getContentDetails(documentId)

    // Then
    assertThat(result.type).isEqualTo("content-document")
    assertThat(result.webCanonical).isEqualTo("https://www.zdf.de/dokumentation/terra-x/faszination-erde-antarktis-102.html")
}

@Test
fun `getContentDetails with profile parameter passes profile to API`() {
    // Given
    val programmeItemId = "epg-zdf-250101_2015-100"
    val profile = "teaser"

    given(zdfMediathekService.getProgrammeItemDetails(programmeItemId, profile))
        .willReturn(mockProgrammeItem)

    // When
    contentDetailsService.getContentDetails(programmeItemId, profile)

    // Then
    verify(zdfMediathekService).getProgrammeItemDetails(programmeItemId, profile)
}
----

==== 2.2 ID-Typ-Erkennung

[source,kotlin]
----
@Test
fun `detects programme item ID pattern and calls correct API`() {
    // Programme item IDs start with "epg-"
    val programmeItemIds = listOf(
        "epg-zdf-250101_2015-100",
        "epg-3sat-180415_1513-100",
        "epg-zdfneo-241225_2200-200"
    )

    programmeItemIds.forEach { id ->
        // Should call getProgrammeItemDetails
        contentDetailsService.getContentDetails(id)
        verify(zdfMediathekService).getProgrammeItemDetails(eq(id), any())
    }
}

@Test
fun `detects content document ID pattern and calls correct API`() {
    val documentIds = listOf(
        "terra-x-faszination-erde-102",
        "collection-index-page-ard-collection-ard-dxjuomfyzdpzag93ojvindnjy2njm2q5oddinde-1042",
        "tatort-der-letzte-zeuge-100"
    )

    documentIds.forEach { id ->
        // Should call getContentDocumentDetails
        contentDetailsService.getContentDetails(id)
        verify(zdfMediathekService).getContentDocumentDetails(eq(id), any())
    }
}
----

==== 2.3 Validierung

[source,kotlin]
----
@Test
fun `getContentDetails with empty ID throws exception`() {
    assertThatThrownBy {
        contentDetailsService.getContentDetails("")
    }
        .isInstanceOf(IllegalArgumentException::class.java)
        .hasMessageContaining("contentId must not be blank")
}

@Test
fun `getContentDetails with blank ID throws exception`() {
    assertThatThrownBy {
        contentDetailsService.getContentDetails("   ")
    }
        .isInstanceOf(IllegalArgumentException::class.java)
        .hasMessageContaining("contentId must not be blank")
}
----

==== 2.4 Error Handling

[source,kotlin]
----
@Test
fun `getContentDetails wraps API exception in RuntimeException`() {
    // Given
    val programmeItemId = "epg-zdf-250101_2015-100"
    given(zdfMediathekService.getProgrammeItemDetails(programmeItemId, null))
        .willThrow(RuntimeException("API error"))

    // When/Then
    assertThatThrownBy {
        contentDetailsService.getContentDetails(programmeItemId)
    }
        .isInstanceOf(RuntimeException::class.java)
        .hasMessageContaining("Failed to retrieve content details")
        .hasCauseInstanceOf(RuntimeException::class.java)
}
----

==== 2.5 Mapping-Tests

[source,kotlin]
----
@Test
fun `mapProgrammeItemToResponse correctly maps all fields including webCanonical`() {
    // Given
    val programmeItem = ProgrammeItemDetails(
        id = "epg-zdf-250101_2015-100",
        title = "Tatort",
        subtitle = "Kriminalfilm Deutschland 2024",
        text = "Kommissarin Lena Odenthal ermittelt...",
        duration = 5400,
        editorialDate = OffsetDateTime.parse("2025-01-01T20:15:00+01:00"),
        tvService = "ZDF",
        hasVideo = true,
        brand = BrandInfo(id = "tatort-brand-100", title = "Tatort"),
        categories = listOf("Krimi", "Spielfilm"),
        teaserImageRef = ImageReference(
            layouts = mapOf("1280x720" to "https://www.zdf.de/assets/tatort-100~1280x720.jpg")
        ),
        target = TargetContent(sharingUrl = "https://www.zdf.de/filme/tatort/der-letzte-zeuge-100.html")
    )

    given(zdfMediathekService.getProgrammeItemDetails(any(), any()))
        .willReturn(programmeItem)

    // When
    val result = contentDetailsService.getContentDetails("epg-zdf-250101_2015-100")

    // Then
    assertThat(result)
        .usingRecursiveComparison()
        .isEqualTo(ContentDetailsResponse(
            id = "epg-zdf-250101_2015-100",
            type = "programme-item",
            title = "Tatort",
            subtitle = "Kriminalfilm Deutschland 2024",
            description = "Kommissarin Lena Odenthal ermittelt...",
            tvService = "ZDF",
            editorialDate = OffsetDateTime.parse("2025-01-01T20:15:00+01:00"),
            duration = 5400,
            hasVideo = true,
            webCanonical = "https://www.zdf.de/filme/tatort/der-letzte-zeuge-100.html",
            imageUrl = "https://www.zdf.de/assets/tatort-100~1280x720.jpg",
            brand = "Tatort",
            categories = listOf("Krimi", "Spielfilm"),
            relatedContent = null,
            availableUntil = null
        ))
}

@Test
fun `mapContentDocumentToResponse correctly maps all fields including webCanonical`() {
    // Given
    val document = ContentDocumentDetails(
        id = "terra-x-faszination-erde-102",
        title = "Terra X: Faszination Erde - Antarktis",
        teasertext = "Dirk Steffens reist...",
        text = "Die Antarktis ist der kälteste Kontinent...",
        editorialDate = OffsetDateTime.parse("2024-12-15T19:30:00+01:00"),
        tvService = "ZDF",
        hasVideo = true,
        webCanonical = "https://www.zdf.de/dokumentation/terra-x/faszination-erde-antarktis-102.html",
        endDate = OffsetDateTime.parse("2026-01-01T00:00:00+01:00"),
        teaserImageRef = ImageReference(
            layouts = mapOf("1280x720" to "https://www.zdf.de/assets/antarktis-102~1280x720.jpg")
        )
    )

    given(zdfMediathekService.getContentDocumentDetails(any(), any()))
        .willReturn(document)

    // When
    val result = contentDetailsService.getContentDetails("terra-x-faszination-erde-102")

    // Then
    assertThat(result.webCanonical).isEqualTo("https://www.zdf.de/dokumentation/terra-x/faszination-erde-antarktis-102.html")
    assertThat(result.availableUntil).isEqualTo(OffsetDateTime.parse("2026-01-01T00:00:00+01:00"))
}

@Test
fun `mapping handles null optional fields gracefully`() {
    // Test with minimal data
    val minimalProgrammeItem = ProgrammeItemDetails(
        id = "epg-test-100",
        title = "Test Show",
        hasVideo = false
    )

    given(zdfMediathekService.getProgrammeItemDetails(any(), any()))
        .willReturn(minimalProgrammeItem)

    // When
    val result = contentDetailsService.getContentDetails("epg-test-100")

    // Then
    assertThat(result.description).isNull()
    assertThat(result.duration).isNull()
    assertThat(result.categories).isNull()
    assertThat(result.webCanonical).isNull()
}
----

=== Erwartete Testanzahl: ~12 Unit Tests

== Phase 3: Integration Tests (ContentDetailsServiceIT)

=== Test-Szenarien

==== 3.1 HTTP-Integration mit WireMock

[source,kotlin]
----
@Test
fun `getProgrammeItemDetails makes correct HTTP request with OAuth2`() {
    // Given: Mock OAuth2 token endpoint
    stubFor(
        post(urlEqualTo("/oauth/token"))
            .willReturn(
                aResponse()
                    .withStatus(200)
                    .withHeader("Content-Type", "application/json")
                    .withBody("""{"access_token":"test-token","token_type":"Bearer","expires_in":3600}""")
            )
    )

    // Mock programme item endpoint
    stubFor(
        get(urlEqualTo("/cmdm/epg/programme-items/epg-zdf-250101_2015-100"))
            .withHeader("Authorization", equalTo("Bearer test-token"))
            .willReturn(
                aResponse()
                    .withStatus(200)
                    .withHeader("Content-Type", "application/json")
                    .withBodyFile("programme_item_details.json")
            )
    )

    // When
    val result = contentDetailsService.getContentDetails("epg-zdf-250101_2015-100")

    // Then
    assertThat(result.id).isEqualTo("epg-zdf-250101_2015-100")
    assertThat(result.type).isEqualTo("programme-item")
    assertThat(result.title).isEqualTo("Tatort: Der letzte Zeuge")
    assertThat(result.webCanonical).isEqualTo("https://www.zdf.de/filme/tatort/der-letzte-zeuge-100.html")

    verify(getRequestedFor(urlEqualTo("/cmdm/epg/programme-items/epg-zdf-250101_2015-100"))
        .withHeader("Authorization", equalTo("Bearer test-token")))
}

@Test
fun `getContentDocumentDetails makes correct HTTP request with path and extension`() {
    // Given: Mock OAuth2
    stubFor(
        post(urlEqualTo("/oauth/token"))
            .willReturn(okJson("""{"access_token":"test-token","token_type":"Bearer","expires_in":3600}"""))
    )

    // Mock content document endpoint
    stubFor(
        get(urlEqualTo("/content/documents/terra-x-faszination-erde-102.json"))
            .withHeader("Authorization", equalTo("Bearer test-token"))
            .willReturn(
                aResponse()
                    .withStatus(200)
                    .withHeader("Content-Type", "application/json")
                    .withBodyFile("content_document_details.json")
            )
    )

    // When
    val result = contentDetailsService.getContentDetails("terra-x-faszination-erde-102")

    // Then
    assertThat(result.id).isEqualTo("terra-x-faszination-erde-102")
    assertThat(result.type).isEqualTo("content-document")
    assertThat(result.title).isEqualTo("Terra X: Faszination Erde - Antarktis")
    assertThat(result.webCanonical).isEqualTo("https://www.zdf.de/dokumentation/terra-x/faszination-erde-antarktis-102.html")

    verify(getRequestedFor(urlEqualTo("/content/documents/terra-x-faszination-erde-102.json")))
}

@Test
fun `getContentDetails with profile parameter includes profile in query`() {
    // Given
    stubFor(post(urlEqualTo("/oauth/token")).willReturn(okJson("""{"access_token":"token","token_type":"Bearer","expires_in":3600}""")))
    stubFor(
        get(urlPathEqualTo("/cmdm/epg/programme-items/epg-zdf-250101_2015-100"))
            .withQueryParam("profile", equalTo("teaser"))
            .willReturn(okJson("{}"))
    )

    // When
    contentDetailsService.getContentDetails("epg-zdf-250101_2015-100", "teaser")

    // Then
    verify(getRequestedFor(urlPathEqualTo("/cmdm/epg/programme-items/epg-zdf-250101_2015-100"))
        .withQueryParam("profile", equalTo("teaser")))
}
----

==== 3.2 Error Handling

[source,kotlin]
----
@Test
fun `handles 404 response for non-existent programme item`() {
    // Given
    stubFor(post(urlEqualTo("/oauth/token")).willReturn(okJson("""{"access_token":"token","token_type":"Bearer","expires_in":3600}""")))
    stubFor(
        get(urlPathEqualTo("/cmdm/epg/programme-items/epg-nonexistent-100"))
            .willReturn(aResponse().withStatus(404))
    )

    // When/Then
    assertThatThrownBy {
        contentDetailsService.getContentDetails("epg-nonexistent-100")
    }
        .isInstanceOf(RuntimeException::class.java)
}

@Test
fun `handles 404 response for non-existent content document`() {
    // Given
    stubFor(post(urlEqualTo("/oauth/token")).willReturn(okJson("""{"access_token":"token","token_type":"Bearer","expires_in":3600}""")))
    stubFor(
        get(urlPathEqualTo("/content/documents/nonexistent-102.json"))
            .willReturn(aResponse().withStatus(404))
    )

    // When/Then
    assertThatThrownBy {
        contentDetailsService.getContentDetails("nonexistent-102")
    }
        .isInstanceOf(RuntimeException::class.java)
}
----

==== 3.3 End-to-End Response Mapping

[source,kotlin]
----
@Test
fun `end-to-end test maps complete programme item response correctly`() {
    // Given
    stubFor(post(urlEqualTo("/oauth/token")).willReturn(okJson("""{"access_token":"token","token_type":"Bearer","expires_in":3600}""")))
    stubFor(
        get(urlPathEqualTo("/cmdm/epg/programme-items/epg-zdf-250101_2015-100"))
            .willReturn(
                aResponse()
                    .withStatus(200)
                    .withHeader("Content-Type", "application/json")
                    .withBodyFile("programme_item_details.json")
            )
    )

    // When
    val result = contentDetailsService.getContentDetails("epg-zdf-250101_2015-100")

    // Then: Verify webCanonical is mapped correctly
    assertThat(result.webCanonical).isEqualTo("https://www.zdf.de/filme/tatort/der-letzte-zeuge-100.html")
    assertThat(result.brand).isEqualTo("Tatort")
    assertThat(result.categories).containsExactly("Krimi", "Spielfilm")
}

@Test
fun `end-to-end test maps complete content document response correctly`() {
    // Given
    stubFor(post(urlEqualTo("/oauth/token")).willReturn(okJson("""{"access_token":"token","token_type":"Bearer","expires_in":3600}""")))
    stubFor(
        get(urlPathEqualTo("/content/documents/terra-x-faszination-erde-102.json"))
            .willReturn(
                aResponse()
                    .withStatus(200)
                    .withHeader("Content-Type", "application/json")
                    .withBodyFile("content_document_details.json")
            )
    )

    // When
    val result = contentDetailsService.getContentDetails("terra-x-faszination-erde-102")

    // Then: Verify webCanonical and availability are mapped correctly
    assertThat(result.webCanonical).isEqualTo("https://www.zdf.de/dokumentation/terra-x/faszination-erde-antarktis-102.html")
    assertThat(result.availableUntil).isNotNull()
}
----

=== Erwartete Testanzahl: ~8 Integration Tests

== Phase 4: Implementierung (TDD - minimal für grüne Tests)

=== 4.1 Service-Implementierung

**Datei: `src/main/kotlin/eu/wiegandt/zdfmediathekmcp/ContentDetailsService.kt`**

[source,kotlin]
----
package eu.wiegandt.zdfmediathekmcp

import eu.wiegandt.zdfmediathekmcp.model.*
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.ai.tool.annotation.Tool
import org.springframework.ai.tool.annotation.ToolParam
import org.springframework.stereotype.Component

@Component
class ContentDetailsService(
    private val zdfMediathekService: ZdfMediathekService
) {
    private val logger: Logger = LoggerFactory.getLogger(ContentDetailsService::class.java)

    @Tool(
        name = "get_content_details",
        description = "Get detailed information about specific ZDF Mediathek content. " +
                     "Supports programme item IDs (from broadcasts) and content document IDs (from search). " +
                     "Returns metadata and a direct link to watch the content in ZDF Mediathek."
    )
    fun getContentDetails(
        @ToolParam(description = "Content ID (programme item or document ID)", required = true)
        contentId: String,
        @ToolParam(description = "Output profile (optional, default: 'default')")
        profile: String? = null
    ): ContentDetailsResponse {
        logger.info("MCP Tool 'get_content_details' called with contentId='{}', profile='{}'", contentId, profile)

        validateContentId(contentId)

        return try {
            if (isProgrammeItemId(contentId)) {
                fetchProgrammeItemDetails(contentId, profile)
            } else {
                fetchContentDocumentDetails(contentId, profile)
            }
        } catch (e: IllegalArgumentException) {
            logger.error("Invalid parameter for get_content_details: {}", e.message)
            throw e
        } catch (e: Exception) {
            logger.error("Error executing get_content_details for contentId '{}': {}", contentId, e.message, e)
            throw RuntimeException("Failed to retrieve content details: ${e.message}", e)
        }
    }

    private fun validateContentId(contentId: String) {
        require(contentId.isNotBlank()) { "contentId must not be blank" }
    }

    private fun isProgrammeItemId(contentId: String): Boolean {
        // Programme Item IDs follow pattern: epg-{sender}-{date}-{nr}
        return contentId.startsWith("epg-")
    }

    private fun fetchProgrammeItemDetails(id: String, profile: String?): ContentDetailsResponse {
        logger.debug("Fetching programme item details for id: {}", id)
        val details = zdfMediathekService.getProgrammeItemDetails(id, profile)
        return mapProgrammeItemToResponse(details)
    }

    private fun fetchContentDocumentDetails(id: String, profile: String?): ContentDetailsResponse {
        logger.debug("Fetching content document details for id: {}", id)
        val details = zdfMediathekService.getContentDocumentDetails(id, profile)
        return mapContentDocumentToResponse(details)
    }

    private fun mapProgrammeItemToResponse(item: ProgrammeItemDetails): ContentDetailsResponse {
        return ContentDetailsResponse(
            id = item.id,
            type = "programme-item",
            title = item.title,
            subtitle = item.subtitle,
            description = item.text ?: item.leadParagraph,
            tvService = item.tvService,
            editorialDate = item.editorialDate,
            duration = item.duration,
            hasVideo = item.hasVideo,
            webCanonical = item.target?.sharingUrl,
            availableUntil = null, // Programme items don't have endDate
            imageUrl = item.teaserImageRef.selectBestImageUrl(),
            brand = item.brand?.title,
            categories = item.categories,
            relatedContent = item.relatedContent?.toRelatedContentInfo()
        )
    }

    private fun mapContentDocumentToResponse(doc: ContentDocumentDetails): ContentDetailsResponse {
        return ContentDetailsResponse(
            id = doc.id,
            type = "content-document",
            title = doc.title,
            subtitle = null, // Content documents typically don't have subtitle
            description = doc.text ?: doc.leadParagraph ?: doc.teasertext,
            tvService = doc.tvService,
            editorialDate = doc.editorialDate,
            duration = null, // Content documents typically don't have duration
            hasVideo = doc.hasVideo,
            webCanonical = doc.webCanonical,
            availableUntil = doc.endDate,
            imageUrl = doc.teaserImageRef.selectBestImageUrl(),
            brand = null, // Content documents don't have brand in same structure
            categories = null, // Would need to extract from different field
            relatedContent = doc.relatedContent?.toRelatedContentInfo()
        )
    }
}
----

=== 4.2 Extension Functions für Mapping

**Datei: `src/main/kotlin/eu/wiegandt/zdfmediathekmcp/model/ContentDetailsMappers.kt`**

[source,kotlin]
----
package eu.wiegandt.zdfmediathekmcp.model

/**
 * Selects the best available image URL from the layouts map.
 * Prefers 1280x720 (HD), falls back to other common sizes.
 */
fun ImageReference?.selectBestImageUrl(): String? {
    val layouts = this?.layouts ?: return null

    return layouts["1280x720"]
        ?: layouts["1920x1080"]
        ?: layouts["768x432"]
        ?: layouts.values.firstOrNull()
}

/**
 * Converts a list of RelatedContentLink to RelatedContentInfo.
 * Filters out entries with null or blank title/target.
 */
fun List<RelatedContentLink>?.toRelatedContentInfo(): List<RelatedContentInfo>? {
    return this?.mapNotNull { link ->
        if (!link.title.isNullOrBlank() && !link.target.isNullOrBlank()) {
            RelatedContentInfo(title = link.title, url = link.target)
        } else null
    }?.ifEmpty { null }
}
----

=== 4.3 ZdfMediathekService erweitern

**Datei: `src/main/kotlin/eu/wiegandt/zdfmediathekmcp/ZdfMediathekService.kt`**

Methoden hinzufügen:

[source,kotlin]
----
@GetExchange("/cmdm/epg/programme-items/{id}")
fun getProgrammeItemDetails(
    @PathVariable id: String,
    @RequestParam(required = false) profile: String? = null
): ProgrammeItemDetails

@GetExchange("/content/documents/{id}.json")
fun getContentDocumentDetails(
    @PathVariable id: String,
    @RequestParam(required = false) profile: String? = null
): ContentDocumentDetails
----

== Phase 5: Refactoring & Optimierung

=== 5.1 Code-Qualität

- DRY-Prinzip: Extension Functions für gemeinsame Mapping-Logik bereits in Phase 4 extrahiert
- Null-Safety: Kotlin Null-Safety optimal genutzt
- Klare Trennung: Mapping-Logik in separate Datei

=== 5.2 Logging-Verbesserungen

Strukturiertes Logging ist bereits in Phase 4 implementiert mit:

- INFO-Level für Tool-Aufrufe
- DEBUG-Level für API-Details
- ERROR-Level für Fehler mit Stack-Traces

=== 5.3 Error Handling

- IllegalArgumentException für Validierungsfehler
- RuntimeException wrapper für API-Fehler
- Aussagekräftige Fehlermeldungen

== Phase 6: Dokumentation & README-Update

=== 6.1 README.md Updates

**Abschnitt: MCP Tools Reference - Currently Available**

Hinzufügen:

[cols="1,2,2"]
|===
| Tool | Description | Key Parameters

| `get_content_details`
| Get detailed information about specific content
| `contentId` (string, required) - Programme item or document ID
`profile` (string, optional) - Output profile
|===

**Neuer Abschnitt: Example Tool Usage**

[source,json]
----
{
  "tool": "get_content_details",
  "arguments": {
    "contentId": "epg-zdf-250101_2015-100"
  }
}
----

**Response Example (ohne Video-URLs, mit webCanonical):**

[source,json]
----
{
  "id": "epg-zdf-250101_2015-100",
  "type": "programme-item",
  "title": "Tatort: Der letzte Zeuge",
  "subtitle": "Kriminalfilm Deutschland 2024",
  "description": "Kommissarin Lena Odenthal ermittelt...",
  "tvService": "ZDF",
  "duration": 5400,
  "hasVideo": true,
  "webCanonical": "https://www.zdf.de/filme/tatort/der-letzte-zeuge-100.html",
  "imageUrl": "https://www.zdf.de/assets/tatort-100~1280x720.jpg",
  "brand": "Tatort",
  "categories": ["Krimi", "Spielfilm"]
}
----

**Workflow-Beispiel hinzufügen:**

----
### Typical Workflow: Search → Details

1. User searches: "Find Tatort episodes"
2. MCP calls `search_content` → returns list with IDs
3. User asks: "Tell me more about the first one"
4. MCP extracts ID from search results
5. MCP calls `get_content_details` with that ID
6. Returns complete information including webCanonical link to ZDF Mediathek

### Typical Workflow: Broadcast → Details

1. User asks: "What aired on ZDF yesterday at 8pm?"
2. MCP calls `get_broadcast_schedule` → returns broadcast with programmeItem ID
3. User asks: "Can I still watch that?"
4. MCP calls `get_content_details` with programme item ID
5. Returns webCanonical link to watch in ZDF Mediathek + availableUntil date
----

=== 6.2 AGENTS.md Updates

**Neuer Abschnitt: Content ID Types**

----
## Understanding Content IDs

The ZDF API uses different types of content identifiers:

### Programme Item IDs
- **Format**: `epg-{sender}-{date}-{number}`
- **Example**: `epg-zdf-250101_2015-100`
- **Source**: Broadcast schedule endpoints (`get_broadcast_schedule`, `get_current_broadcast`)
- **Use Case**: EPG data, linear TV broadcasts

### Content Document IDs
- **Format**: Various patterns (collection IDs, content IDs, etc.)
- **Examples**:
  - `terra-x-faszination-erde-102`
  - `collection-index-page-ard-collection-ard-dxjuomfyzdpzag93ojvindnjy2njm2q5oddinde-1042`
- **Source**: Search endpoints (`search_content`)
- **Use Case**: On-demand content, mediathek content

The `get_content_details` tool automatically detects the ID type and routes to the correct API endpoint.
----

**Tool-Beschreibung ergänzen:**

----
### get_content_details

**Purpose**: Retrieve comprehensive metadata about specific ZDF Mediathek content.

**When to use**:
- After `search_content` to get full details about search results
- After `get_broadcast_schedule` to get details about aired programmes
- When user asks for more information about specific content

**Automatic ID Detection**:
The tool automatically recognizes whether you're passing a programme item ID (from EPG) or a content document ID (from search) and calls the appropriate API endpoint.

**Parameters**:
- `contentId` (required): Either a programme item ID or content document ID
- `profile` (optional): API profile for different detail levels (default: "default")

**Returns**:
- Complete metadata including title, description, duration
- `webCanonical` - Direct link to watch in ZDF Mediathek
- Image URLs for thumbnails
- Related content links
- Availability information (`availableUntil` - when content expires from mediathek)

**Note**: This tool does NOT return direct video streaming URLs. Use `webCanonical` to provide users a link to watch content in the official ZDF Mediathek.

**Example Usage**:
```json
{
  "tool": "get_content_details",
  "arguments": {
    "contentId": "epg-zdf-250101_2015-100"
  }
}
```

**LLM Tips**:
- Extract content IDs from previous tool results (search results, broadcast items)
- Use this for "tell me more" or "show details" queries
- Check `availableUntil` field to inform users about mediathek availability
- Use `webCanonical` to provide direct links to ZDF Mediathek for watching content
----

== Zusammenfassung

=== Kern-Features

✅ Unterstützt Programme Item IDs (EPG)
✅ Unterstützt Content Document IDs (Search)
✅ Automatische ID-Typ-Erkennung
✅ Optionaler Profile-Parameter
✅ Nur `webCanonical` Links - keine direkten Video-URLs
✅ OAuth2-Integration
✅ Umfangreiches Error Handling
✅ Strukturiertes Logging

=== Technische Highlights

- **Zwei API-Endpoints** in einem MCP-Tool vereint
- **Smart Routing** basierend auf ID-Format
- **Einheitliche Response-Struktur** trotz unterschiedlicher Quellen
- **Keine Video-URLs** - nur Links zur offiziellen ZDF Mediathek
- **Testabdeckung >80%** durch umfangreiche Unit & Integration Tests

=== Erwartete Testanzahl

- **Unit Tests**: ~12 Tests
- **Integration Tests**: ~8 Tests
- **Gesamt**: ~20 Tests

=== Implementierungs-Reihenfolge

1. **Phase 1**: Setup (Models, Mocks, Test-Struktur)
2. **Phase 2**: Unit Tests schreiben (alle rot)
3. **Phase 3**: Integration Tests schreiben (alle rot)
4. **Phase 4**: Implementierung (Tests grün machen)
5. **Phase 5**: Refactoring (Code-Qualität verbessern)
6. **Phase 6**: Dokumentation (README, AGENTS.md, KDoc)

=== Nächste Schritte

Nach Genehmigung des Plans:

1. Phase 1 starten: Test-Dateien und Model-Strukturen anlegen
2. Kompilierung sicherstellen
3. Test-Suite vorbereiten
4. TDD-Zyklus beginnen (Red → Green → Refactor)

